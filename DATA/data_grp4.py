# -*- coding: utf-8 -*-
"""DATA_GRP4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13u1rB3TQebXZrYbeEMEfXghIb3NV3q7v
"""

import yfinance as yf
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Définition des tickers et de la période d'analyse
ETF_symbol = "IWDA.AS"
FCP_symbol = "0P0001D3JD.F"
SICAV_symbol = "0P00014NXZ.F"

start_date = "2020-01-01"
end_date = "2025-01-01"

# Téléchargement des données via yfinance
print("Téléchargement des données en cours...")
ETF_data = yf.download(ETF_symbol, start=start_date, end=end_date)
FCP_data = yf.download(FCP_symbol, start=start_date, end=end_date)
SICAV_data = yf.download(SICAV_symbol, start=start_date, end=end_date)

print(ETF_data)
print(FCP_data)
print(SICAV_data)

# Vérification de la disponibilité des données
data = {"ETF": ETF_data, "FCP": FCP_data, "SICAV": SICAV_data}
for name, df in data.items():
    if df.empty:
        print(f"Aucune donnée trouvée pour {name} ! Vérifiez le ticker sur Yahoo Finance.")
    else:
        print(f"\nDonnées trouvées pour {name} :")
        print(df.head())

# Ne garder que la colonne 'Close' et renommer les colonnes
ETF_data = ETF_data[['Close']].rename(columns={'Close': f'ETF_{ETF_symbol}'})
FCP_data = FCP_data[['Close']].rename(columns={'Close': f'FCP_{FCP_symbol}'})
SICAV_data = SICAV_data[['Close']].rename(columns={'Close': f'SICAV_{SICAV_symbol}'})

# Fusion des trois DataFrames en un seul
prix_fonds = pd.concat([ETF_data, FCP_data, SICAV_data], axis=1)
if prix_fonds.empty:
    raise ValueError("Le DataFrame prix_fonds est vide. Vérifiez les tickers et la récupération des données.")

print("\nAperçu du DataFrame fusionné (prix_fonds) :")
print(prix_fonds.head())

# Calcul des rendements quotidiens pour chaque colonne
rendements_fonds = prix_fonds.pct_change(fill_method=None).dropna()

# Définition des taux d'imposition selon les pays
impots_pays = {
    "France": 0.25,       # 25% d'imposition
    "Luxembourg": 0.17,   # 17% d'imposition
    "Irlande": 0.125      # 12.5% d'imposition
}

# Calcul des rendements nets après impôts pour chaque pays

rendements_nets_pays = {}
for pays, taux in impots_pays.items():
    rendements_nets = rendements_fonds * (1 - taux)
    rendements_nets_pays[pays] = rendements_nets

# Affichage des performances après fiscalité pour chaque pays

for pays, df in rendements_nets_pays.items():
    plt.figure(figsize=(10, 5))
    for column in df.columns:
        performance_cumulee = (1 + df[column]).cumprod() - 1
        plt.plot(performance_cumulee, label=str(column))
    plt.title(f"Performance Après Fiscalité - {pays} (Taux: {impots_pays[pays]*100:.1f}%)")
    plt.xlabel("Date")
    plt.ylabel("Rendement Cumulatif")
    plt.legend()
    plt.show()

# Affichage des données finales
for pays, df in rendements_nets_pays.items():
    print(f"\nRendements Nets des Fonds en {pays} :")
    print(df.head())

# Calcul des rendements cumulés AVANT et APRES fiscalité
rendements_cumules = (1 + rendements_fonds).cumprod() - 1
rendements_cumules_nets = {pays: (1 + df).cumprod() - 1 for pays, df in rendements_nets_pays.items()}

# Comparaison sur un même graphique
plt.figure(figsize=(12, 6))
for column in rendements_cumules.columns:
    plt.plot(rendements_cumules[column], label=f"{column} (Brut)", linestyle="dashed")

for pays, df in rendements_cumules_nets.items():
    for column in df.columns:
        plt.plot(df[column], label=f"{column} (Net {pays})")

plt.title("Comparaison des performances avant et après fiscalité")
plt.xlabel("Date")
plt.ylabel("Rendement Cumulatif")
plt.legend()
plt.tight_layout()
plt.show()

# Moyenne et volatilité des rendements avant et après impôt
stats_fonds = {
    "Brut": rendements_fonds.describe().loc[['mean', 'std']].T
}

for pays, df in rendements_nets_pays.items():
    stats_fonds[pays] = df.describe().loc[['mean', 'std']].T

# Création d'un DataFrame récapitulatif
stats_comparatif = pd.concat(stats_fonds, axis=1)
stats_comparatif.columns = ['Moyenne Brute', 'Volatilité Brute'] + \
                           [f"Moyenne {pays}" for pays in impots_pays.keys()] + \
                           [f"Volatilité {pays}" for pays in impots_pays.keys()]

# Calcul du ratio de Sharpe avant et après fiscalité (on suppose un taux sans risque à 0)
ratio_sharpe = {
    "Brut": (rendements_fonds.mean() / rendements_fonds.std()).to_frame(name="Ratio Sharpe Brut")
}

for pays, df in rendements_nets_pays.items():
    ratio_sharpe[pays] = (df.mean() / df.std()).to_frame(name=f"Ratio Sharpe {pays}")

# Création d'un DataFrame récapitulatif
sharpe_comparatif = pd.concat(ratio_sharpe, axis=1) # Change stats_fonds to ratio_sharpe
sharpe_comparatif.columns = ['Ratio de Sharpe Brute'] + \
                           [f"Ratio de Sharpe {pays}" for pays in impots_pays.keys()]

# Affichage des statistiques comparatives et des ratios de Sharpe
print("\nComparaison des rendements avant/après fiscalité :")
print(stats_comparatif)

print("\nComparaison des Ratios de Sharpe :")
print(sharpe_comparatif)

# Matrice de corrélation des rendements
plt.figure(figsize=(10, 6))
sns.heatmap(rendements_fonds.corr(), annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.title('Matrice de Corrélation des Rendements des Fonds')
plt.show()

# Supposons un taux sans risque annuel à 2%
taux_sans_risque_annuel = 0.02
taux_sans_risque_quotidien = taux_sans_risque_annuel / 252

# Ratio Sortino avant fiscalité
rendements_negatifs = rendements_fonds[rendements_fonds < 0].std() * np.sqrt(252)
sortino_brut = ((rendements_fonds.mean() * 252) - taux_sans_risque_annuel) / rendements_negatifs

print("\nRatio Sortino Brut (avant impôts):")
print(sortino_brut)

# Ratio Sortino après fiscalité par pays
for pays, df in rendements_nets_pays.items():
    rendements_negatifs_net = df[df < 0].std() * np.sqrt(252)
    sortino_net = ((df.mean() * 252) - taux_sans_risque_annuel) / rendements_negatifs_net
    print(f"\nRatio Sortino Net en {pays}:")
    print(sortino_net)

from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

# Fonction pour le clustering selon le pays
def clustering_fonds_pays(rendements_nets, pays, n_clusters_range=(2,6)):
    scaler = StandardScaler()
    rendements_standardises = scaler.fit_transform(rendements_nets.dropna())

    pca = PCA(n_components=2)
    rendements_pca = pca.fit_transform(rendements_standardises)

    # Calcul du score silhouette pour déterminer le nombre optimal de clusters
    scores_silhouette = []
    for k in range(*n_clusters_range):
        kmeans = KMeans(n_clusters=k, random_state=42)
        labels = kmeans.fit_predict(rendements_pca)
        score = silhouette_score(rendements_pca, labels)
        scores_silhouette.append(score)

    # Graphique des scores silhouette
    plt.figure(figsize=(10, 6))
    plt.plot(range(*n_clusters_range), scores_silhouette, marker='o')
    plt.title(f'Score Silhouette optimal ({pays})')
    plt.xlabel('Nombre de clusters')
    plt.ylabel('Score Silhouette')
    plt.show()

    # Choisir le nombre optimal de clusters selon le meilleur score silhouette
    optimal_clusters = np.argmax(scores_silhouette) + n_clusters_range[0]
    kmeans = KMeans(n_clusters=optimal_clusters, random_state=42)
    labels_clusters = kmeans.fit_predict(rendements_pca)

    # Graphique des clusters
    plt.figure(figsize=(10, 6))
    sns.scatterplot(x=rendements_pca[:,0], y=rendements_pca[:,1], hue=labels_clusters, palette='viridis')
    plt.title(f'Clusters des Fonds (après fiscalité en {pays})')
    plt.xlabel('Composante PCA 1')
    plt.ylabel('Composante PCA 2')
    plt.legend(title='Cluster')
    plt.show()

    # Résumé statistique par cluster
    df_clusters = pd.DataFrame(rendements_nets.iloc[:len(labels_clusters)])
    df_clusters['Cluster'] = labels_clusters
    resume_clusters = df_clusters.groupby('Cluster').mean()
    print(f"\nRésumé des clusters après fiscalité ({pays}) :")
    print(resume_clusters)

# Appliquer la fonction aux différents pays
pays_a_traiter = ['France', 'Luxembourg', 'Irlande']
for pays in pays_a_traiter:
    clustering_fonds_pays(rendements_nets_pays[pays], pays)